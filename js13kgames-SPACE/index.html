<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  
  <script type="module">

			import * as THREE from 'https://threejs.org/build/three.module.js';

			import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
			import { GUI } from 'https://threejs.org/examples/jsm/libs/dat.gui.module.js';

			import { TrackballControls } from 'https://threejs.org/examples/jsm/controls/TrackballControls.js';

			let perspectiveCamera, orthographicCamera, controls, scene, renderer, stats;

			const params = {
				orthographicCamera: false
			};

			const frustumSize = 400;
	  
	  		var pickArray = [];
	  
	  		var pickmesh = {};

			init();
			animate();

			function init() {

				const aspect = window.innerWidth / window.innerHeight;

				perspectiveCamera = new THREE.PerspectiveCamera( 5, aspect, 1, 1000 );
				perspectiveCamera.position.z = 500;

				orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
				orthographicCamera.position.z = 500;

				// world

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				const geometry = new THREE.SphereGeometry( 15, 32, 32 );
				const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
				const mesh = new THREE.Mesh( geometry, material );
				mesh.updateMatrix();
				mesh.matrixAutoUpdate = false;
				scene.add( mesh );
				pickArray.push( mesh )

				// lights

				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				const ambientLight = new THREE.AmbientLight( 0x222222 );
				scene.add( ambientLight );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				

				const gui = new GUI();
				gui.add( params, 'orthographicCamera' ).name( 'use orthographic' ).onChange( function ( value ) {

					controls.dispose();

					createControls( value ? orthographicCamera : perspectiveCamera );

				} );

				//

				window.addEventListener( 'resize', onWindowResize );

				createControls( perspectiveCamera );

			}

			function createControls( camera ) {

				controls = new TrackballControls( camera, renderer.domElement );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.keys = [ 'KeyA', 'KeyS', 'KeyD' ];

			}

			function onWindowResize() {

				const aspect = window.innerWidth / window.innerHeight;

				perspectiveCamera.aspect = aspect;
				perspectiveCamera.updateProjectionMatrix();

				orthographicCamera.left = - frustumSize * aspect / 2;
				orthographicCamera.right = frustumSize * aspect / 2;
				orthographicCamera.top = frustumSize / 2;
				orthographicCamera.bottom = - frustumSize / 2;
				orthographicCamera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();

				stats.update();

				render();

			}

			function render() {

				const camera = ( params.orthographicCamera ) ? orthographicCamera : perspectiveCamera;

				renderer.render( scene, camera );
				const mouse = new THREE.Vector2();
				mouse.x = ( (window.innerWidth/2) / window.innerWidth ) * 2 - 1;
				mouse.y = - ( (window.innerHeight/2) / window.innerHeight ) * 2 + 1 -5;
				var raycaster = new THREE.Raycaster();
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( pickArray );
				
				if(intersects.length > 0){
					if(!pickmesh.type){
						const pickgeometry = new THREE.SphereGeometry( 5, 32, 32 );
						const pickmaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
						pickmesh = new THREE.Mesh( pickgeometry, pickmaterial );
						scene.add( pickmesh );
					}
					pickmesh.lookAt(camera.position);
					pickmesh.position.x = intersects[0].point.x;
					pickmesh.position.y = intersects[0].point.y;
					pickmesh.position.z = intersects[0].point.z;
					
				}

			}


		</script>
</body>

</html>
